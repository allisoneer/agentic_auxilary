use anyhow::{Context, Result};
use cargo_metadata::MetadataCommand;
use clap::{Parser, Subcommand};
use std::fs;
use std::path::PathBuf;

pub mod autogen;
pub mod claude;
pub mod marker;
pub mod policy;
pub mod release_plz;
pub mod sync;
pub mod verify;

#[derive(Parser, Debug)]
#[command(name = "xtask", about = "Repo maintenance tasks")]
struct Args {
    #[command(subcommand)]
    cmd: Cmd,
}

#[derive(Subcommand, Debug)]
enum Cmd {
    /// Sync README dependency versions inside autodeps markers
    ReadmeSync {
        /// Path to the README (defaults to repo root README.md)
        #[arg(long, default_value = "README.md")]
        path: PathBuf,
        /// Dry-run: print diffable output to stdout but don't write
        #[arg(long)]
        dry_run: bool,
        /// Check mode: fail if README is out of sync (for CI)
        #[arg(long)]
        check: bool,
    },
    /// Sync autogenerated content (CLAUDE.md files, release-plz.toml)
    Sync {
        /// Dry-run: print what would change but don't write
        #[arg(long)]
        dry_run: bool,
        /// Check mode: fail if any files are out of sync (for CI)
        #[arg(long)]
        check: bool,
    },
    /// Verify metadata, policy rules, and generated file freshness
    Verify {
        /// Check mode: also verify generated files are up to date
        #[arg(long)]
        check: bool,
    },
}

fn strict_mode() -> bool {
    matches!(std::env::var("AUTODEPS_STRICT"), Ok(v) if v == "1" || v.eq_ignore_ascii_case("true"))
}

fn main() -> Result<()> {
    let args = Args::parse();
    match args.cmd {
        Cmd::ReadmeSync {
            path,
            dry_run,
            check,
        } => readme_sync(path, dry_run, check),
        Cmd::Sync { dry_run, check } => sync::run(dry_run, check),
        Cmd::Verify { check } => verify::run(check),
    }
}

fn readme_sync(path: PathBuf, dry_run: bool, check: bool) -> Result<()> {
    let metadata = MetadataCommand::new()
        .no_deps()
        .exec()
        .context("Failed to run `cargo metadata`")?;
    let strict = strict_mode();
    let input =
        fs::read_to_string(&path).with_context(|| format!("Failed to read {}", path.display()))?;

    let (output, changed) = marker::apply_autodeps_markers(
        &input,
        &marker::RenderContext {
            metadata: &metadata,
            strict,
        },
    )?;

    if !changed {
        eprintln!("[autodeps] No changes needed for {}", path.display());
        return Ok(());
    }

    if check {
        anyhow::bail!("README is out of sync. Run `cargo run -p xtask -- readme-sync` to update.");
    }

    if dry_run {
        println!("{output}");
    } else {
        fs::write(&path, output).with_context(|| format!("Failed to write {}", path.display()))?;
        eprintln!("[autodeps] Updated {}", path.display());
    }

    Ok(())
}
